{
  "version": 3,
  "file": "stateProvider.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter\\angularjs\\stateProvider.ts"
  ],
  "names": [],
  "mappings": "AAAA,6BAA6B,CAAC,MAAM;AACpC,OAAO,EACL,GAAG,EACH,QAAQ,EACR,oBAAoB,GAKrB,MAAM,gBAAgB,CAAC;AAGxB;;;;;;;;;;;;;;;GAeG;AACH;IACE,uBAAoB,aAA4B,EAAU,YAA0B;QAAhE,kBAAa,GAAb,aAAa,CAAe;QAAU,iBAAY,GAAZ,YAAY,CAAc;QAClF,oBAAoB,CAAC,GAAG,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE,IAAI,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;IACtE,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAwFG;IACH,iCAAS,GAAT,UAAU,IAAY,EAAE,IAAqB;QAC3C,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,IAAI,CAAC;IAC1D,CAAC;IAwID,6BAAK,GAAL,UAAM,IAAS,EAAE,UAAgB;QAC/B,IAAI,QAAQ,CAAC,IAAI,CAAC,EAAE;YAClB,UAAU,GAAG,IAAI,CAAC;SACnB;aAAM;YACL,UAAU,CAAC,IAAI,GAAG,IAAI,CAAC;SACxB;QACD,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QACxC,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;OAIG;IAEH,iCAAS,GAAT,UAAU,QAA2B;QACnC,OAAO,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;IAC/C,CAAC;IACH,oBAAC;AAAD,CAAC,AA3PD,IA2PC",
  "sourcesContent": [
    "/** @publicapi @module ng1 */ /** */\r\nimport {\r\n  val,\r\n  isObject,\r\n  createProxyFunctions,\r\n  BuilderFunction,\r\n  StateRegistry,\r\n  StateService,\r\n  OnInvalidCallback,\r\n} from '@uirouter/core';\r\nimport { Ng1StateDeclaration } from './interface';\r\n\r\n/**\r\n * The Angular 1 `StateProvider`\r\n *\r\n * The `$stateProvider` works similar to Angular's v1 router, but it focuses purely\r\n * on state.\r\n *\r\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\r\n * navigation. A state describes (via the controller / template / view properties) what\r\n * the UI looks like and does at that place.\r\n *\r\n * States often have things in common, and the primary way of factoring out these\r\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\r\n * nested states.\r\n *\r\n * The `$stateProvider` provides interfaces to declare these states for your app.\r\n */\r\nexport class StateProvider {\r\n  constructor(private stateRegistry: StateRegistry, private stateService: StateService) {\r\n    createProxyFunctions(val(StateProvider.prototype), this, val(this));\r\n  }\r\n\r\n  /**\r\n   * Decorates states when they are registered\r\n   *\r\n   * Allows you to extend (carefully) or override (at your own peril) the\r\n   * `stateBuilder` object used internally by [[StateRegistry]].\r\n   * This can be used to add custom functionality to ui-router,\r\n   * for example inferring templateUrl based on the state name.\r\n   *\r\n   * When passing only a name, it returns the current (original or decorated) builder\r\n   * function that matches `name`.\r\n   *\r\n   * The builder functions that can be decorated are listed below. Though not all\r\n   * necessarily have a good use case for decoration, that is up to you to decide.\r\n   *\r\n   * In addition, users can attach custom decorators, which will generate new\r\n   * properties within the state's internal definition. There is currently no clear\r\n   * use-case for this beyond accessing internal states (i.e. $state.$current),\r\n   * however, expect this to become increasingly relevant as we introduce additional\r\n   * meta-programming features.\r\n   *\r\n   * **Warning**: Decorators should not be interdependent because the order of\r\n   * execution of the builder functions in non-deterministic. Builder functions\r\n   * should only be dependent on the state definition object and super function.\r\n   *\r\n   *\r\n   * Existing builder functions and current return values:\r\n   *\r\n   * - **parent** `{object}` - returns the parent state object.\r\n   * - **data** `{object}` - returns state data, including any inherited data that is not\r\n   *   overridden by own values (if any).\r\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\r\n   *   or `null`.\r\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is\r\n   *   navigable).\r\n   * - **params** `{object}` - returns an array of state params that are ensured to\r\n   *   be a super-set of parent's params.\r\n   * - **views** `{object}` - returns a views object where each key is an absolute view\r\n   *   name (i.e. \"viewName@stateName\") and each value is the config object\r\n   *   (template, controller) for the view. Even when you don't use the views object\r\n   *   explicitly on a state config, one is still created for you internally.\r\n   *   So by decorating this builder function you have access to decorating template\r\n   *   and controller properties.\r\n   * - **ownParams** `{object}` - returns an array of params that belong to the state,\r\n   *   not including any params defined by ancestor states.\r\n   * - **path** `{string}` - returns the full path from the root down to this state.\r\n   *   Needed for state activation.\r\n   * - **includes** `{object}` - returns an object that includes every state that\r\n   *   would pass a `$state.includes()` test.\r\n   *\r\n   * #### Example:\r\n   * Override the internal 'views' builder with a function that takes the state\r\n   * definition, and a reference to the internal function being overridden:\r\n   * ```js\r\n   * $stateProvider.decorator('views', function (state, parent) {\r\n   *   let result = {},\r\n   *       views = parent(state);\r\n   *\r\n   *   angular.forEach(views, function (config, name) {\r\n   *     let autoName = (state.name + '.' + name).replace('.', '/');\r\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\r\n   *     result[name] = config;\r\n   *   });\r\n   *   return result;\r\n   * });\r\n   *\r\n   * $stateProvider.state('home', {\r\n   *   views: {\r\n   *     'contact.list': { controller: 'ListController' },\r\n   *     'contact.item': { controller: 'ItemController' }\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   *\r\n   * ```js\r\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\r\n   * // and /partials/home/contact/item.html, respectively.\r\n   * $state.go('home');\r\n   * ```\r\n   *\r\n   * @param {string} name The name of the builder function to decorate.\r\n   * @param {object} func A function that is responsible for decorating the original\r\n   * builder function. The function receives two parameters:\r\n   *\r\n   *   - `{object}` - state - The state config object.\r\n   *   - `{object}` - super - The original builder function.\r\n   *\r\n   * @return {object} $stateProvider - $stateProvider instance\r\n   */\r\n  decorator(name: string, func: BuilderFunction) {\r\n    return this.stateRegistry.decorator(name, func) || this;\r\n  }\r\n\r\n  /**\r\n   * Registers a state\r\n   *\r\n   * ### This is a passthrough to [[StateRegistry.register]].\r\n   *\r\n   * Registers a state configuration under a given state name.\r\n   * The stateConfig object has the following acceptable properties.\r\n   *\r\n   * <a id='template'></a>\r\n   *\r\n   * - **`template`** - {string|function=} - html template as a string or a function that returns\r\n   *   an html template as a string which should be used by the uiView directives. This property\r\n   *   takes precedence over templateUrl.\r\n   *\r\n   *   If `template` is a function, it will be called with the following parameters:\r\n   *\r\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\r\n   *     applying the current state\r\n   *\r\n   * <a id='templateUrl'></a>\r\n   *\r\n   * - **`templateUrl`** - {string|function=} - path or function that returns a path to an html\r\n   *   template that should be used by uiView.\r\n   *\r\n   *   If `templateUrl` is a function, it will be called with the following parameters:\r\n   *\r\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\r\n   *     applying the current state\r\n   *\r\n   * <a id='templateProvider'></a>\r\n   *\r\n   * - **`templateProvider`** - {function=} - Provider function that returns HTML content\r\n   *   string.\r\n   *\r\n   * <a id='controller'></a>\r\n   *\r\n   * - **`controller`** - {string|function=} -  Controller fn that should be associated with newly\r\n   *   related scope or the name of a registered controller if passed as a string.\r\n   *\r\n   * <a id='controllerProvider'></a>\r\n   *\r\n   * - **`controllerProvider`** - {function=} - Injectable provider function that returns\r\n   *   the actual controller or string.\r\n   *\r\n   * <a id='controllerAs'></a>\r\n   *\r\n   * - **`controllerAs`** – {string=} – A controller alias name. If present the controller will be\r\n   *   published to scope under the controllerAs name.\r\n   *\r\n   * <a id='resolve'></a>\r\n   *\r\n   * - **`resolve`** - {object.&lt;string, function&gt;=} - An optional map of dependencies which\r\n   *   should be injected into the controller. If any of these dependencies are promises,\r\n   *   the router will wait for them all to be resolved or one to be rejected before the\r\n   *   controller is instantiated. If all the promises are resolved successfully, the values\r\n   *   of the resolved promises are injected and $stateChangeSuccess event is fired. If any\r\n   *   of the promises are rejected the $stateChangeError event is fired. The map object is:\r\n   *\r\n   *   - key - {string}: name of dependency to be injected into controller\r\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function,\r\n   *     it is injected and return value it treated as dependency. If result is a promise, it is\r\n   *     resolved before its value is injected into controller.\r\n   *\r\n   * <a id='url'></a>\r\n   *\r\n   * - **`url`** - {string=} - A url with optional parameters. When a state is navigated or\r\n   *   transitioned to, the `$stateParams` service will be populated with any\r\n   *   parameters that were passed.\r\n   *\r\n   * <a id='params'></a>\r\n   *\r\n   * - **`params`** - {object=} - An array of parameter names or regular expressions. Only\r\n   *   use this within a state if you are not using url. Otherwise you can specify your\r\n   *   parameters within the url. When a state is navigated or transitioned to, the\r\n   *   $stateParams service will be populated with any parameters that were passed.\r\n   *\r\n   * <a id='views'></a>\r\n   *\r\n   * - **`views`** - {object=} - Use the views property to set up multiple views or to target views\r\n   *   manually/explicitly.\r\n   *\r\n   * <a id='abstract'></a>\r\n   *\r\n   * - **`abstract`** - {boolean=} - An abstract state will never be directly activated,\r\n   *   but can provide inherited properties to its common children states.\r\n   *\r\n   * <a id='onEnter'></a>\r\n   *\r\n   * - **`onEnter`** - {object=} - Callback function for when a state is entered. Good way\r\n   *   to trigger an action or dispatch an event, such as opening a dialog.\r\n   * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\r\n   *\r\n   * <a id='onExit'></a>\r\n   *\r\n   * - **`onExit`** - {object=} - Callback function for when a state is exited. Good way to\r\n   *   trigger an action or dispatch an event, such as opening a dialog.\r\n   * If minifying your scripts, make sure to use the `['injection1', 'injection2', function(injection1, injection2){}]` syntax.\r\n   *\r\n   * <a id='reloadOnSearch'></a>\r\n   *\r\n   * - **`reloadOnSearch = true`** - {boolean=} - If `false`, will not retrigger the same state\r\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()).\r\n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\r\n   *\r\n   * <a id='data'></a>\r\n   *\r\n   * - **`data`** - {object=} - Arbitrary data object, useful for custom configuration.\r\n   *\r\n   * #### Example:\r\n   * Some state name examples\r\n   * ```js\r\n   * // stateName can be a single top-level name (must be unique).\r\n   * $stateProvider.state(\"home\", {});\r\n   *\r\n   * // Or it can be a nested state name. This state is a child of the\r\n   * // above \"home\" state.\r\n   * $stateProvider.state(\"home.newest\", {});\r\n   *\r\n   * // Nest states as deeply as needed.\r\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\r\n   *\r\n   * // state() returns $stateProvider, so you can chain state declarations.\r\n   * $stateProvider\r\n   *   .state(\"home\", {})\r\n   *   .state(\"about\", {})\r\n   *   .state(\"contacts\", {});\r\n   * ```\r\n   *\r\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\r\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\r\n   * @param {object} definition State configuration object.\r\n   */\r\n  state(name: string, definition: Ng1StateDeclaration): StateProvider;\r\n  state(definition: Ng1StateDeclaration): StateProvider;\r\n  state(name: any, definition?: any) {\r\n    if (isObject(name)) {\r\n      definition = name;\r\n    } else {\r\n      definition.name = name;\r\n    }\r\n    this.stateRegistry.register(definition);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Registers an invalid state handler\r\n   *\r\n   * This is a passthrough to [[StateService.onInvalid]] for ng1.\r\n   */\r\n\r\n  onInvalid(callback: OnInvalidCallback): Function {\r\n    return this.stateService.onInvalid(callback);\r\n  }\r\n}\r\n"
  ]
}