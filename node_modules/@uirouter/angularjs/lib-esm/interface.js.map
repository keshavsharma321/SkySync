{
  "version": 3,
  "file": "interface.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter\\angularjs\\interface.ts"
  ],
  "names": [],
  "mappings": "",
  "sourcesContent": [
    "/** @publicapi @module ng1 */ /** */\r\nimport { StateDeclaration, _ViewDeclaration, IInjectable, Transition, HookResult, StateRegistry } from '@uirouter/core';\r\n\r\n/**\r\n * The signature for Angular 1 State Transition Hooks.\r\n *\r\n * State hooks are registered as onEnter/onRetain/onExit in state declarations.\r\n * State hooks can additionally be injected with $transition$ and $state$ for\r\n * the current [[Transition]] and [[StateObject]] in the transition.\r\n *\r\n * Transition State Hooks are callback functions that hook into the lifecycle events of specific states during a transition.\r\n * As a transition runs, it may exit some states, retain (keep) states, and enter states.\r\n * As each lifecycle event occurs, the hooks which are registered for the event and that state are called (in priority order).\r\n *\r\n * #### See also:\r\n *\r\n * - [[IHookRegistry.onExit]]\r\n * - [[IHookRegistry.onRetain]]\r\n * - [[IHookRegistry.onEnter]]\r\n *\r\n * #### Example:\r\n * ```js\r\n * onEnter: function() { console.log('Entering'); }\r\n * ```\r\n *\r\n * Not minification-safe\r\n * ```js\r\n * onRetain: function($state$) { console.log('Retained ' + $state$.name); }\r\n * ```\r\n *\r\n * Annotated for minification-safety\r\n * ```js\r\n * onExit: [ '$transition$', '$state', function($transition$, $state) {\r\n *   // always redirect to 'foo' state when being exited\r\n *   if ($transition$.to().name !== 'foo') {\r\n *     return $state.target('foo');\r\n *   }\r\n * } ]\r\n * ```\r\n *\r\n * @returns an optional [[HookResult]] which may alter the transition\r\n */\r\nexport interface Ng1StateTransitionHook {\r\n  (...injectables: any[]): HookResult;\r\n}\r\n\r\n/**\r\n * @internalapi\r\n * an intermediate interface.\r\n *\r\n * Used to reset [[StateDeclaration]] typings to `any` so the [[Ng1StateDeclaration]] interface can then narrow them */\r\nexport interface _Ng1StateDeclaration extends StateDeclaration {\r\n  onExit?: any;\r\n  onRetain?: any;\r\n  onEnter?: any;\r\n  views?: any;\r\n}\r\n\r\n/**\r\n * The StateDeclaration object is used to define a state or nested state.\r\n * It should be registered with the [[StateRegistry]].\r\n *\r\n * #### Example:\r\n * ```js\r\n * // StateDeclaration object\r\n * var foldersState = {\r\n *   name: 'folders',\r\n *   url: '/folders',\r\n *   resolve: {\r\n *     allfolders: function(FolderService) {\r\n *       return FolderService.list();\r\n *     }\r\n *   },\r\n *   template: \"<ul><li ng-repeat='folder in allfolders'>{{folder.name}}</li></ul>\",\r\n *   controller: function(allfolders, $scope) {\r\n *     $scope.allfolders = allfolders;\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * Since this interface extends [[Ng1ViewDeclaration]], any view declaration properties can be set directly\r\n * on the state declaration and they will be applied to the view with the name `$default`.  For example:\r\n *\r\n * ```js\r\n * var state = {\r\n *   name: 'foo',\r\n *   url: '/foo',\r\n *   template: '<h1>foo</h1>',\r\n *   controller: 'FooController'\r\n * }\r\n * ```\r\n *\r\n * is simply syntactic sugar for:\r\n *\r\n * ```js\r\n * var state = {\r\n *   name: 'foo',\r\n *   url: '/foo',\r\n *   views: {\r\n *     $default: {\r\n *       template: '<h1>foo</h1>',\r\n *       controller: 'FooController'\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * If a state definition contains a `views:` object, any view properties set directly on the state are ignored.\r\n * Thus, this is an invalid state defintion:\r\n *\r\n * ```js\r\n * var state = {\r\n *   name: 'foo',\r\n *   url: '/foo',\r\n *   controller: 'FooController', // invalid because views: exists\r\n *   views: {\r\n *     header: {\r\n *       template: '<h1>header</h1>'\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport interface Ng1StateDeclaration extends _Ng1StateDeclaration, Ng1ViewDeclaration {\r\n  /**\r\n   * An optional object which defines multiple named views.\r\n   *\r\n   * Each key is the name of a view, and each value is a [[Ng1ViewDeclaration]].\r\n   * Unnamed views are internally renamed to `$default`.\r\n   *\r\n   * A view's name is used to match an active `<ui-view>` directive in the DOM.  When the state\r\n   * is entered, the state's views are activated and matched with active `<ui-view>` directives:\r\n   *\r\n   * - The view's name is processed into a ui-view target:\r\n   *   - ui-view address: an address to a ui-view\r\n   *   - state anchor: the state to anchor the address to\r\n   *\r\n   *  Examples:\r\n   *\r\n   *  Targets three named ui-views in the parent state's template\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * views: {\r\n   *   header: {\r\n   *     controller: \"headerCtrl\",\r\n   *     templateUrl: \"header.html\"\r\n   *   },\r\n   *   body: {\r\n   *     controller: \"bodyCtrl\",\r\n   *     templateUrl: \"body.html\"\r\n   *   },\r\n   *   footer: \"footerComponent\"\r\n   * }\r\n   * ```\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * // Targets named ui-view=\"header\" in the template of the ancestor state 'top'\r\n   * // and the named `ui-view=\"body\" from the parent state's template.\r\n   * views: {\r\n   *   'header@top': {\r\n   *     controller: \"msgHeaderCtrl\",\r\n   *     templateUrl: \"msgHeader.html\"\r\n   *   },\r\n   *   'body': {\r\n   *     controller: \"messagesCtrl\",\r\n   *     templateUrl: \"messages.html\"\r\n   *   }\r\n   * }\r\n   * ```\r\n   *\r\n   * ## View targeting details\r\n   *\r\n   * There are a few styles of view addressing/targeting.\r\n   * The most common is a simple `ui-view` name\r\n   *\r\n   * #### Simple ui-view name\r\n   *\r\n   * Addresses without an `@` are anchored to the parent state.\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * // target the `<div ui-view='foo'></div>` created in the parent state's view\r\n   * views: {\r\n   *   foo: {...}\r\n   * }\r\n   * ```\r\n   *\r\n   * #### View name anchored to a state\r\n   *\r\n   * You can anchor the `ui-view` name to a specific state by including an `@`\r\n   *\r\n   * #### Example:\r\n   * targets the `<div ui-view='foo'></div>` which was created in a view owned by the state `bar.baz`\r\n   * ```js\r\n   * views: {\r\n   *   'foo@bar.baz': {...}\r\n   * }\r\n   * ```\r\n   *\r\n   * #### Absolute addressing\r\n   *\r\n   * You can address a `ui-view` absolutely, using dotted notation, by prefixing the address with a `!`.\r\n   * Dotted addresses traverse the hierarchy of `ui-view`s active in the DOM:\r\n   *\r\n   * #### Example:\r\n   * absolutely targets the `<div ui-view='nested'></div>`\r\n   * ... which was created in the unnamed/$default root `<ui-view></ui-view>`\r\n   * ```js\r\n   * views: {\r\n   *   '!$default.nested': {...}\r\n   * }\r\n   * ```\r\n   *\r\n   * #### Relative addressing\r\n   *\r\n   * Absolute addressing is actually relative addressing, anchored to the unnamed root state (`\"\"`).\r\n   * You can also use relative addressing anchored to *any state*, in order to target a target deeply nested `ui-views`:\r\n   * The `ui-view` is targeted relative to the anchored state by traversing the nested `ui-view` names.\r\n   *\r\n   * #### Example:\r\n   * targets the `<div ui-view='bar'></div>`\r\n   * ... which was created inside the\r\n   * `<div ui-view='foo'></div>`\r\n   * ... which was created inside the parent state's template.\r\n   * ```js\r\n   * views: {\r\n   *   'foo.bar': {...}\r\n   * }\r\n   * ```\r\n   *\r\n   * #### Example:\r\n   * targets the `<div ui-view='bar'></div>`\r\n   * ... which was created in `<div ui-view='foo'></div>`\r\n   * ... which was created in a template from the state `baz.qux`\r\n   * ```js\r\n   * views: {\r\n   *   'foo.bar@baz.qux': {...}\r\n   * }\r\n   * ```\r\n   *\r\n   * #### Example:\r\n   * a view can relatively target a named `ui-view` defined on an ancestor using `^` (meaning \"parent\")\r\n   * ```js\r\n   * views: {\r\n   *   'foo@^': {...}, // foo@(parent state) (same as simply 'foo')\r\n   *   'bar@^.^': {...}, // bar@(grandparent state)\r\n   *   'baz@^.^.^': {...}, // baz@(great-grandparent state)\r\n   * }\r\n   * ```\r\n   *\r\n   * For additional in-depth details about how `ui-view` addressing works, see the internal api [[ViewService.match]].\r\n   *\r\n   * ---\r\n   *\r\n   * ## State template+controller and `views:` incompatiblity\r\n   *\r\n   * If a state has a `views` object, any state-level view properties ([[Ng1ViewDeclaration]]) are ignored.  Therefore,\r\n   * if _any view_ for a state is declared in the `views` object, then _all of the state's views_ must be defined in\r\n   * the `views` object.  The state declaration must not have any of the following fields:\r\n   * - component\r\n   * - bindings\r\n   * - resolveAs\r\n   * - template\r\n   * - templateUrl\r\n   * - templateProvider\r\n   * - controller\r\n   * - controllerAs\r\n   * - controllerProvider\r\n   */\r\n  views?: { [key: string]: string | Ng1ViewDeclaration };\r\n\r\n  /**\r\n   * A state hook invoked when a state is being entered.\r\n   *\r\n   * The hook can inject global services.\r\n   * It can also inject `$transition$` or `$state$` (from the current transition).\r\n   *\r\n   * ### Example:\r\n   * ```js\r\n   * $stateProvider.state({\r\n   *   name: 'mystate',\r\n   *   onEnter: (MyService, $transition$, $state$) => {\r\n   *     return MyService.doSomething($state$.name, $transition$.params());\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   * #### Example:`\r\n   * ```js\r\n   * $stateProvider.state({\r\n   *   name: 'mystate',\r\n   *   onEnter: [ 'MyService', '$transition$', '$state$', function (MyService, $transition$, $state$) {\r\n   *     return MyService.doSomething($state$.name, $transition$.params());\r\n   *   } ]\r\n   * });\r\n   * ```\r\n   */\r\n  onEnter?: Ng1StateTransitionHook | IInjectable;\r\n\r\n  /**\r\n   * A state hook invoked when a state is being exited.\r\n   *\r\n   * The hook can inject global services.\r\n   * It can also inject `$transition$` or `$state$` (from the current transition).\r\n   *\r\n   * ### Example:\r\n   * ```js\r\n   * $stateProvider.state({\r\n   *   name: 'mystate',\r\n   *   onExit: (MyService, $transition$, $state$) => {\r\n   *     return MyService.doSomething($state$.name, $transition$.params());\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   * #### Example:`\r\n   * ```js\r\n   * $stateProvider.state({\r\n   *   name: 'mystate',\r\n   *   onExit: [ 'MyService', '$transition$', '$state$', function (MyService, $transition$, $state$) {\r\n   *     return MyService.doSomething($state$.name, $transition$.params());\r\n   *   } ]\r\n   * });\r\n   * ```\r\n   */\r\n  onExit?: Ng1StateTransitionHook | IInjectable;\r\n\r\n  /**\r\n   * A state hook invoked when a state is being retained.\r\n   *\r\n   * The hook can inject global services.\r\n   * It can also inject `$transition$` or `$state$` (from the current transition).\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * $stateProvider.state({\r\n   *   name: 'mystate',\r\n   *   onRetain: (MyService, $transition$, $state$) => {\r\n   *     return MyService.doSomething($state$.name, $transition$.params());\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   * #### Example:`\r\n   * ```js\r\n   * $stateProvider.state({\r\n   *   name: 'mystate',\r\n   *   onRetain: [ 'MyService', '$transition$', '$state$', function (MyService, $transition$, $state$) {\r\n   *     return MyService.doSomething($state$.name, $transition$.params());\r\n   *   } ]\r\n   * });\r\n   * ```\r\n   */\r\n  onRetain?: Ng1StateTransitionHook | IInjectable;\r\n\r\n  /**\r\n   * Makes all search/query parameters `dynamic`\r\n   *\r\n   * ### Deprecation warning: use [[ParamDeclaration.dynamic]] instead\r\n   *\r\n   * @deprecated\r\n   */\r\n  reloadOnSearch?: boolean;\r\n}\r\n\r\nexport interface Ng1ViewDeclaration extends _ViewDeclaration {\r\n  /**\r\n   * The name of the component to use for this view.\r\n   *\r\n   * A property of [[Ng1StateDeclaration]] or [[Ng1ViewDeclaration]]:\r\n   *\r\n   * The name of an [angular 1.5+ `.component()`](https://docs.angularjs.org/guide/component) (or directive with\r\n   * bindToController and/or scope declaration) which will be used for this view.\r\n   *\r\n   * Resolve data can be provided to the component via the component's `bindings` object (for 1.3+ directives, the\r\n   * `bindToController` is used; for other directives, the `scope` declaration is used).  For each binding declared\r\n   * on the component, any resolve with the same name is set on the component's controller instance.  The binding\r\n   * is provided to the component as a one-time-binding.  In general, components should likewise declare their\r\n   * input bindings as [one-way (\"&lt;\")](https://docs.angularjs.org/api/ng/service/$compile#-scope-).\r\n   *\r\n   * Note: inside a \"views:\" block, a bare string `\"foo\"` is shorthand for `{ component: \"foo\" }`\r\n   *\r\n   * Note: Mapping from resolve names to component inputs may be specified using [[bindings]].\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * .state('profile', {\r\n   *   // Use the <my-profile></my-profile> component for the Unnamed view\r\n   *   component: 'MyProfile',\r\n   * }\r\n   *\r\n   * .state('messages', {\r\n   *   // use the <nav-bar></nav-bar> component for the view named 'header'\r\n   *   // use the <message-list></message-list> component for the view named 'content'\r\n   *   views: {\r\n   *     header: { component: 'NavBar' },\r\n   *     content: { component: 'MessageList' }\r\n   *   }\r\n   * }\r\n   *\r\n   * .state('contacts', {\r\n   *   // Inside a \"views:\" block, a bare string \"NavBar\" is shorthand for { component: \"NavBar\" }\r\n   *   // use the <nav-bar></nav-bar> component for the view named 'header'\r\n   *   // use the <contact-list></contact-list> component for the view named 'content'\r\n   *   views: {\r\n   *     header: 'NavBar',\r\n   *     content: 'ContactList'\r\n   *   }\r\n   * }\r\n   * ```\r\n   *\r\n   *\r\n   * Note: When using `component` to define a view, you may _not_ use any of: `template`, `templateUrl`,\r\n   * `templateProvider`, `controller`, `controllerProvider`, `controllerAs`.\r\n   *\r\n   *\r\n   * See also: Todd Motto's angular 1.3 and 1.4 [backport of .component()](https://github.com/toddmotto/angular-component)\r\n   */\r\n  component?: string;\r\n\r\n  /**\r\n   * An object which maps `resolve`s to [[component]] `bindings`.\r\n   *\r\n   * A property of [[Ng1StateDeclaration]] or [[Ng1ViewDeclaration]]:\r\n   *\r\n   * When using a [[component]] declaration (`component: 'myComponent'`), each input binding for the component is supplied\r\n   * data from a resolve of the same name, by default.  You may supply data from a different resolve name by mapping it here.\r\n   *\r\n   * Each key in this object is the name of one of the component's input bindings.\r\n   * Each value is the name of the resolve that should be provided to that binding.\r\n   *\r\n   * Any component bindings that are omitted from this map get the default behavior of mapping to a resolve of the\r\n   * same name.\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * $stateProvider.state('foo', {\r\n   *   resolve: {\r\n   *     foo: function(FooService) { return FooService.get(); },\r\n   *     bar: function(BarService) { return BarService.get(); }\r\n   *   },\r\n   *   component: 'Baz',\r\n   *   // The component's `baz` binding gets data from the `bar` resolve\r\n   *   // The component's `foo` binding gets data from the `foo` resolve (default behavior)\r\n   *   bindings: {\r\n   *     baz: 'bar'\r\n   *   }\r\n   * });\r\n   *\r\n   * app.component('Baz', {\r\n   *   templateUrl: 'baz.html',\r\n   *   controller: 'BazController',\r\n   *   bindings: {\r\n   *     foo: '<', // foo binding\r\n   *     baz: '<'  // baz binding\r\n   *   }\r\n   * });\r\n   * ```\r\n   *\r\n   */\r\n  bindings?: { [key: string]: string };\r\n\r\n  /**\r\n   * Dynamic component provider function.\r\n   *\r\n   * A property of [[Ng1StateDeclaration]] or [[Ng1ViewDeclaration]]:\r\n   *\r\n   * This is an injectable provider function which returns the name of the component to use.\r\n   * The provider will invoked during a Transition in which the view's state is entered.\r\n   * The provider is called after the resolve data is fetched.\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * componentProvider: function(MyResolveData, $transition$) {\r\n   *   if (MyResolveData.foo) {\r\n   *     return \"fooComponent\"\r\n   *   } else if ($transition$.to().name === 'bar') {\r\n   *     return \"barComponent\";\r\n   *   }\r\n   * }\r\n   * ```\r\n   */\r\n  componentProvider?: IInjectable;\r\n\r\n  /**\r\n   * The view's controller function or name\r\n   *\r\n   * A property of [[Ng1StateDeclaration]] or [[Ng1ViewDeclaration]]:\r\n   *\r\n   * The controller function, or the name of a registered controller.  The controller function will be used\r\n   * to control the contents of the [[directives.uiView]] directive.\r\n   *\r\n   * If specified as a string, controllerAs can be declared here, i.e., \"FooController as foo\" instead of in\r\n   * a separate [[controllerAs]] property.\r\n   *\r\n   * See: [[Ng1Controller]] for information about component-level router hooks.\r\n   */\r\n  controller?: IInjectable | string;\r\n\r\n  /**\r\n   * A controller alias name.\r\n   *\r\n   * A property of [[Ng1StateDeclaration]] or [[Ng1ViewDeclaration]]:\r\n   *\r\n   * If present, the controller will be published to scope under the `controllerAs` name.\r\n   * See: https://docs.angularjs.org/api/ng/directive/ngController\r\n   */\r\n  controllerAs?: string;\r\n\r\n  /**\r\n   * Dynamic controller provider function.\r\n   *\r\n   * A property of [[Ng1StateDeclaration]] or [[Ng1ViewDeclaration]]:\r\n   *\r\n   * This is an injectable provider function which returns the actual controller function, or the name\r\n   * of a registered controller.  The provider will invoked during a Transition in which the view's state is\r\n   * entered.  The provider is called after the resolve data is fetched.\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * controllerProvider: function(MyResolveData, $transition$) {\r\n   *   if (MyResolveData.foo) {\r\n   *     return \"FooCtrl\"\r\n   *   } else if ($transition$.to().name === 'bar') {\r\n   *     return \"BarCtrl\";\r\n   *   } else {\r\n   *     return function($scope) {\r\n   *       $scope.baz = \"Qux\";\r\n   *     }\r\n   *   }\r\n   * }\r\n   * ```\r\n   */\r\n  controllerProvider?: IInjectable;\r\n\r\n  /**\r\n   * The scope variable name to use for resolve data.\r\n   *\r\n   * A property of [[Ng1StateDeclaration]] or [[Ng1ViewDeclaration]]:\r\n   *\r\n   * When a view is activated, the resolved data for the state which the view belongs to is put on the scope.\r\n   * This property sets the name of the scope variable to use for the resolved data.\r\n   *\r\n   * Defaults to `$resolve`.\r\n   */\r\n  resolveAs?: string;\r\n\r\n  /**\r\n   * The HTML template for the view.\r\n   *\r\n   * A property of [[Ng1StateDeclaration]] or [[Ng1ViewDeclaration]]:\r\n   *\r\n   * HTML template as a string, or a function which returns an html template as a string.\r\n   * This template will be used to render the corresponding [[directives.uiView]] directive.\r\n   *\r\n   * This property takes precedence over templateUrl.\r\n   *\r\n   * If `template` is a function, it will be called with the Transition parameters as the first argument.\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * template: \"<h1>inline template definition</h1><div ui-view></div>\"\r\n   * ```\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * template: function(params) {\r\n   *   return \"<h1>generated template</h1>\";\r\n   * }\r\n   * ```\r\n   */\r\n  template?: Function | string;\r\n\r\n  /**\r\n   * The URL for the HTML template for the view.\r\n   *\r\n   * A property of [[Ng1StateDeclaration]] or [[Ng1ViewDeclaration]]:\r\n   *\r\n   * A path or a function that returns a path to an html template.\r\n   * The template will be fetched and used to render the corresponding [[directives.uiView]] directive.\r\n   *\r\n   * If `templateUrl` is a function, it will be called with the Transition parameters as the first argument.\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * templateUrl: \"/templates/home.html\"\r\n   * ```\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * templateUrl: function(params) {\r\n   *   return myTemplates[params.pageId];\r\n   * }\r\n   * ```\r\n   */\r\n  templateUrl?: string | Function;\r\n\r\n  /**\r\n   * Injected function which returns the HTML template.\r\n   *\r\n   * A property of [[Ng1StateDeclaration]] or [[Ng1ViewDeclaration]]:\r\n   *\r\n   * Injected function which returns the HTML template.\r\n   * The template will be used to render the corresponding [[directives.uiView]] directive.\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * templateProvider: function(MyTemplateService, $transition$) {\r\n   *   return MyTemplateService.getTemplate($transition$.params().pageId);\r\n   * }\r\n   * ```\r\n   */\r\n  templateProvider?: IInjectable;\r\n}\r\n\r\n/**\r\n * The shape of a controller for a view (and/or component), defining the controller callbacks.\r\n *\r\n * A view in UI-Router is comprised of either a `component` ([[Ng1ViewDeclaration.component]]) or a combination of a\r\n * `template` (or `templateProvider`) and a `controller` (or `controllerProvider`).\r\n *\r\n * The `controller` object (or the `component`'s controller object) can define component-level controller callbacks,\r\n * which UI-Router will call at the appropriate times.  These callbacks are similar to Transition Hooks\r\n * ([[IHookRegistry]]), but are only called if the view is currently active.\r\n *\r\n * This interface defines the UI-Router component callbacks.\r\n *\r\n */\r\nexport interface Ng1Controller {\r\n  /** @hidden */\r\n  $onInit(): void;\r\n  /**\r\n   * This callback is called when parameter values have changed.\r\n   *\r\n   * This callback can be used to respond to changing parameter values in the current state, or in parent/child states.\r\n   * This callback is especially handy when using dynamic parameters ([[ParamDeclaration.dynamic]])\r\n   *\r\n   * Called when:\r\n   * - The view is still active\r\n   * - A new transition has completed successfully\r\n   * - The state for the view (controller) was not reloaded\r\n   * - At least one parameter value was changed\r\n   *\r\n   * Called with:\r\n   * @param newValues an object containing the changed parameter values\r\n   * @param $transition$ the new Transition which triggered this callback\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * angular.module('foo').controller('FancyCtrl', function() {\r\n   *   this.uiOnParamsChanged = function(newParams) {\r\n   *     console.log(\"new params: \", newParams);\r\n   *   }\r\n   * });\r\n   * ```\r\n   */\r\n  uiOnParamsChanged(newValues: any, $transition$: Transition): void;\r\n\r\n  /**\r\n   * This callback is called when the view's state is about to be exited.\r\n   *\r\n   * This callback is used to inform a view that it is about to be exited, due to a new [[Transition]].\r\n   * The callback can ask for user confirmation, and cancel or alter the new Transition.  The callback should\r\n   * return a value, or a promise for a value.  If a promise is returned, the new Transition waits until the\r\n   * promise settles.\r\n   *\r\n   *\r\n   * Called when:\r\n   * - The view is still active\r\n   * - A new Transition is about to run\r\n   * - The new Transition will exit the view's state\r\n   *\r\n   * Called with:\r\n   * - The new Transition\r\n   *\r\n   * Relevant return Values:\r\n   * - `false`: The transition is cancelled.\r\n   * - A rejected promise: The transition is cancelled.\r\n   * - [[TargetState]]: The transition is redirected to the new target state.\r\n   * - Anything else: the transition will continue normally (the state and view will be deactivated)\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * app.component('myComponent', {\r\n   *   template: '<input ng-model=\"$ctrl.data\" type=\"text\">',\r\n   *   bindings: { 'data': '<' },\r\n   *   controller: function() {\r\n   *\r\n   *     this.originalData = angular.copy(this.data);\r\n   *\r\n   *     this.uiCanExit = function() {\r\n   *       if (!angular.equals(this.data, this.originalData)) {\r\n   *         // Note: This could also return a Promise and request async\r\n   *         // confirmation using something like ui-bootstrap $modal\r\n   *         return window.confirm(\"Data has changed.  Exit anyway and lose changes?\");\r\n   *       }\r\n   *     }\r\n   *   }\r\n   * }\r\n   * ```\r\n   *\r\n   * @param transition the new Transition that is about to exit the component's state\r\n   * @return a HookResult, or a promise for a HookResult\r\n   */\r\n  uiCanExit(transition: Transition): HookResult;\r\n}\r\n\r\n/**\r\n * Manages which template-loading mechanism to use.\r\n *\r\n * Defaults to `$templateRequest` on Angular versions starting from 1.3, `$http` otherwise.\r\n */\r\nexport interface TemplateFactoryProvider {\r\n  /**\r\n   * Forces $templateFactory to use $http instead of $templateRequest.\r\n   *\r\n   * UI-Router uses `$templateRequest` by default on angular 1.3+.\r\n   * Use this method to choose to use `$http` instead.\r\n   *\r\n   * ---\r\n   *\r\n   * ## Security warning\r\n   *\r\n   * This might cause XSS, as $http doesn't enforce the regular security checks for\r\n   * templates that have been introduced in Angular 1.3.\r\n   *\r\n   * See the $sce documentation, section\r\n   * <a href=\"https://docs.angularjs.org/api/ng/service/$sce#impact-on-loading-templates\">\r\n   * Impact on loading templates</a> for more details about this mechanism.\r\n   *\r\n   * *Note: forcing this to `false` on Angular 1.2.x will crash, because `$templateRequest` is not implemented.*\r\n   *\r\n   * @param useUnsafeHttpService `true` to use `$http` to fetch templates\r\n   */\r\n  useHttpService(useUnsafeHttpService: boolean);\r\n}\r\n\r\ndeclare module '@uirouter/core/lib/state/stateRegistry' {\r\n  interface StateRegistry {\r\n    register(state: Ng1StateDeclaration | { new (): Ng1StateDeclaration });\r\n  }\r\n}\r\n"
  ]
}