{
  "version": 3,
  "file": "resolveService.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter\\angularjs\\legacy\\resolveService.ts"
  ],
  "names": [],
  "mappings": "AAAA,6BAA6B,CAAC,MAAM;AACpC,OAAO,EAAE,WAAW,EAAE,QAAQ,EAAE,cAAc,EAAO,MAAM,EAAE,kBAAkB,EAAE,MAAM,gBAAgB,CAAC;AACxG,OAAO,KAAK,OAAO,MAAM,SAAS,CAAC;AAEnC;;GAEG;AACH,IAAM,QAAQ,GAAG;IACf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAmCG;IACH,OAAO,EAAE,UAAC,UAAuC,EAAE,MAAW,EAAE,MAAqB;QAAlC,uBAAA,EAAA,WAAW;QAC5D,IAAM,UAAU,GAAG,IAAI,QAAQ,CAAC,IAAI,WAAW,CAAM,EAAE,MAAM,EAAE,EAAE,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;QACvF,IAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,IAAI,WAAW,CAAM,EAAE,MAAM,EAAE,EAAE,EAAE,WAAW,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;QACjF,IAAM,OAAO,GAAG,IAAI,cAAc,CAAC,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC,CAAC;QAEvD,OAAO,CAAC,cAAc,CAAC,kBAAkB,CAAM,EAAE,OAAO,EAAE,UAAU,EAAE,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QAErF,IAAM,WAAW,GAAG,UAAC,YAAiB;YACpC,IAAM,MAAM,GAAG,UAAC,OAAY,IAAK,OAAA,kBAAkB,CAAM,EAAE,OAAO,EAAE,MAAM,CAAC,OAAO,EAAE,UAAC,KAAK,IAAK,OAAA,cAAM,OAAA,KAAK,EAAL,CAAK,EAAX,CAAW,CAAC,EAAE,CAAC,EAA7E,CAA6E,CAAC;YAC/G,OAAO,CAAC,cAAc,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC;YAC/D,OAAO,CAAC,cAAc,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;YAEnD,IAAM,WAAW,GAAG,UAAC,GAAQ,EAAE,KAAiC;gBAC9D,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC;gBAC/B,OAAO,GAAG,CAAC;YACb,CAAC,CAAC;YACF,OAAO,OAAO,CAAC,WAAW,EAAE,CAAC,IAAI,CAAC,UAAC,OAAO,IAAK,OAAA,OAAO,CAAC,MAAM,CAAC,WAAW,EAAE,EAAE,CAAC,EAA/B,CAA+B,CAAC,CAAC;QAClF,CAAC,CAAC;QAEF,OAAO,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;IAC7D,CAAC;CACF,CAAC;AAEF,cAAc;AACd,MAAM,CAAC,IAAM,cAAc,GAAG,cAAM,OAAA,QAAQ,EAAR,CAAQ,CAAC;AAE7C,2BAA2B;AAC3B,OAAO,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC,UAAU,EAAO,cAAc,CAAC,CAAC",
  "sourcesContent": [
    "/** @publicapi @module ng1 */ /** */\r\nimport { StateObject, PathNode, ResolveContext, Obj, mapObj, resolvablesBuilder } from '@uirouter/core';\r\nimport * as angular from 'angular';\r\n\r\n/**\r\n * Implementation of the legacy `$resolve` service for angular 1.\r\n */\r\nconst $resolve = {\r\n  /**\r\n   * Asynchronously injects a resolve block.\r\n   *\r\n   * This emulates most of the behavior of the ui-router 0.2.x $resolve.resolve() service API.\r\n   *\r\n   * ### Not bundled by default\r\n   *\r\n   * This API is no longer not part of the standard `@uirouter/angularjs` bundle.\r\n   * For users of the prebuilt bundles, add the `release/resolveService.min.js` UMD bundle.\r\n   * For bundlers (webpack, browserify, etc), add `@uirouter/angularjs/lib/legacy/resolveService`.\r\n   *\r\n   * ---\r\n   *\r\n   * Given an object `invocables`, where keys are strings and values are injectable functions,\r\n   * injects each function, and waits for the resulting promise to resolve.\r\n   * When all resulting promises are resolved, returns the results as an object.\r\n   *\r\n   * #### Example:\r\n   * ```js\r\n   * let invocables = {\r\n   *   foo: [ '$http', ($http) =>\r\n   *            $http.get('/api/foo').then(resp => resp.data) ],\r\n   *   bar: [ 'foo', '$http', (foo, $http) =>\r\n   *            $http.get('/api/bar/' + foo.barId).then(resp => resp.data) ]\r\n   * }\r\n   * $resolve.resolve(invocables)\r\n   *     .then(results => console.log(results.foo, results.bar))\r\n   * // Logs foo and bar:\r\n   * // { id: 123, barId: 456, fooData: 'foo data' }\r\n   * // { id: 456, barData: 'bar data' }\r\n   * ```\r\n   *\r\n   * @param invocables an object which looks like an [[StateDeclaration.resolve]] object; keys are resolve names and values are injectable functions\r\n   * @param locals key/value pre-resolved data (locals)\r\n   * @param parent a promise for a \"parent resolve\"\r\n   */\r\n  resolve: (invocables: { [key: string]: Function }, locals = {}, parent?: Promise<any>) => {\r\n    const parentNode = new PathNode(new StateObject(<any>{ params: {}, resolvables: [] }));\r\n    const node = new PathNode(new StateObject(<any>{ params: {}, resolvables: [] }));\r\n    const context = new ResolveContext([parentNode, node]);\r\n\r\n    context.addResolvables(resolvablesBuilder(<any>{ resolve: invocables }), node.state);\r\n\r\n    const resolveData = (parentLocals: Obj) => {\r\n      const rewrap = (_locals: Obj) => resolvablesBuilder(<any>{ resolve: mapObj(_locals, (local) => () => local) });\r\n      context.addResolvables(rewrap(parentLocals), parentNode.state);\r\n      context.addResolvables(rewrap(locals), node.state);\r\n\r\n      const tuples2ObjR = (acc: Obj, tuple: { token: any; value: any }) => {\r\n        acc[tuple.token] = tuple.value;\r\n        return acc;\r\n      };\r\n      return context.resolvePath().then((results) => results.reduce(tuples2ObjR, {}));\r\n    };\r\n\r\n    return parent ? parent.then(resolveData) : resolveData({});\r\n  },\r\n};\r\n\r\n/** @hidden */\r\nexport const resolveFactory = () => $resolve;\r\n\r\n// The old $resolve service\r\nangular.module('ui.router').factory('$resolve', <any>resolveFactory);\r\n"
  ]
}